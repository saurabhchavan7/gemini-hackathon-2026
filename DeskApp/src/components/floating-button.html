<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LifeOS Capture Button</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      width: 280px;
      height: 280px;
    }

    .button-wrapper {
      position: relative;
      -webkit-app-region: drag;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 110px;
      height: 110px;
      margin: 20px auto 0;
    }

    /* Outer draggable ring - Solid, colored, FULLY DRAGGABLE */
    .drag-ring {
      position: absolute;
      width: 104px;
      height: 104px;
      border-radius: 50%;
      border: 4px solid rgba(26, 115, 232, 0.5);
      background: rgba(26, 115, 232, 0.02);
      transition: all 0.3s ease;
      z-index: 1;
      -webkit-app-region: drag;
      cursor: move;
      pointer-events: auto;
    }

    .button-wrapper:hover .drag-ring {
      border-color: rgba(26, 115, 232, 0.8);
      border-width: 5px;
      background: rgba(26, 115, 232, 0.08);
    }

    .button-wrapper.dragging .drag-ring {
      border-color: #1a73e8;
      border-width: 6px;
      background: rgba(26, 115, 232, 0.15);
    }

    .main-button {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #1a73e8;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 4px 16px rgba(0, 0, 0, 0.12);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      -webkit-app-region: no-drag;
      position: relative;
      user-select: none;
      z-index: 10;
    }

    .main-button:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 8px 24px rgba(0, 0, 0, 0.15);
      transform: scale(1.05);
    }

    .main-button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    }

    .main-button.capturing {
      background: #34a853;
    }

    .main-button.processing {
      background: #fbbc04;
    }

    .main-button.error {
      background: #ea4335;
    }

    .main-icon {
      font-size: 28px;
      line-height: 1;
      user-select: none;
      pointer-events: none;
    }

    .close-button {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #ea4335;
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
      -webkit-app-region: no-drag;
      z-index: 10;
    }

    .main-button:hover .close-button {
      display: flex;
    }

    .close-button:hover {
      background: #d33b2c;
      transform: scale(1.1);
    }

    .menu-container {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(16px);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      -webkit-app-region: no-drag;
      z-index: 100;
      margin-top: 8px;
      padding: 0 10px;
    }

    .menu-container.show {
      opacity: 1;
      pointer-events: all;
      transform: translateX(-50%) translateY(0);
    }

    .menu-options {
      display: flex;
      flex-direction: row;
      gap: 12px;
      align-items: center;
      justify-content: center;
    }

    .menu-item {
      width: 50px;
      height: 50px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      background: white;
      border: none;
      border-radius: 50%;
      text-align: center;
      font-size: 22px;
      color: #202124;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 4px 12px rgba(0, 0, 0, 0.08);
      line-height: 1;
      overflow: visible;
    }

    .menu-item:hover {
      transform: scale(1.15);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 8px 20px rgba(0, 0, 0, 0.12);
    }

    .menu-item:active {
      transform: scale(0.95);
    }

    .menu-item::before {
      font-size: 26px;
      line-height: 1;
      letter-spacing: 0;
    }

    .menu-item.text::before {
      content: 'üìù';
    }

    .menu-item.audio::before {
      content: 'üé§';
    }

    .menu-item.file::before {
      content: 'üìé';
    }

    .tooltip {
      position: absolute;
      bottom: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(60, 64, 67, 0.95);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      -webkit-app-region: no-drag;
    }

    .tooltip.show {
      opacity: 1;
    }

    .spinner {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      animation: spin 0.8s linear infinite;
      display: none;
    }

    .main-button.processing .spinner {
      display: block;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      display: none;
      z-index: 50;
      -webkit-app-region: no-drag;
    }

    .backdrop.show {
      display: block;
    }
  </style>
</head>

<body>
  <div class="button-wrapper" id="buttonWrapper">
    <div class="drag-ring" id="dragRing"></div>
    <div class="main-button" id="mainButton">
      <div class="main-icon" id="mainIcon">üì∏</div>
      <div class="spinner"></div>
      <div class="close-button" id="closeButton">√ó</div>
    </div>
    <div class="menu-container" id="menuContainer">
      <div class="menu-options">
        <div class="menu-item text" data-action="text" title="Text Note"></div>
        <div class="menu-item audio" data-action="audio" title="Audio Note"></div>
        <div class="menu-item file" data-action="file" title="Attach File"></div>
      </div>
    </div>
    <div class="backdrop" id="backdrop"></div>
    <div class="tooltip" id="tooltip">Click to capture</div>
  </div>

  <script>
    const mainButton = document.getElementById('mainButton');
    const closeButton = document.getElementById('closeButton');
    const menuContainer = document.getElementById('menuContainer');
    const backdrop = document.getElementById('backdrop');
    const tooltip = document.getElementById('tooltip');
    const mainIcon = document.getElementById('mainIcon');
    const menuItems = document.querySelectorAll('.menu-item');
    const buttonWrapper = document.getElementById('buttonWrapper');
    const dragRing = document.getElementById('dragRing');

    let isCapturing = false;
    let clickCount = 0;
    let clickTimer = null;
    let isDragging = false;
    let pendingCapture = null;
    let pendingFile = null;
    let autoSendTimer = null;

    window.electronAPI.onCaptureSentSuccess(() => {
      tooltip.textContent = 'Saved ‚úÖ';
      tooltip.classList.add('show');
      isCapturing = false;
      pendingCapture = null;
      mainButton.classList.remove('processing');
      setTimeout(() => {
        tooltip.classList.remove('show');
      }, 2000);
    });

    window.electronAPI.onCaptureSentFailed((error) => {
      console.error('‚ùå Capture send failed:', error);
      tooltip.textContent = 'Failed ‚ùå';
      tooltip.classList.add('show');
      isCapturing = false;
      pendingCapture = null;
      mainButton.classList.remove('processing', 'capturing');
      mainButton.classList.add('error');
      setTimeout(() => {
        tooltip.classList.remove('show');
        mainButton.classList.remove('error');
      }, 2000);
    });

    window.electronAPI.onCaptureNotificationClosed?.(() => {
      console.log('üîî Notification closed, resetting button state');
      isCapturing = false;
      pendingCapture = null;
      mainButton.classList.remove('processing', 'capturing', 'error');
      tooltip.classList.remove('show');
    });

    let dragTimeout;
    window.addEventListener('mousemove', () => {
      if (!isDragging) {
        isDragging = true;
        buttonWrapper.classList.add('dragging');
        clearTimeout(dragTimeout);
        dragTimeout = setTimeout(() => {
          isDragging = false;
          buttonWrapper.classList.remove('dragging');
        }, 500);
      }
    });

    document.addEventListener('click', (e) => {
      if (menuContainer.classList.contains('show')) {
        // Only close if clicking is NOT on menu items or main button
        const clickedMenuItem = e.target.closest('.menu-item');
        const clickedButton = e.target.closest('.main-button');
        
        // Close menu only if click is outside both
        if (!clickedMenuItem && !clickedButton) {
          closeMenu();
        }
      }
    });

    backdrop.addEventListener('click', (e) => {
      e.stopPropagation();
      closeMenu();
    });

    mainButton.addEventListener('click', (e) => {
      e.stopPropagation();
      clickCount++;
      if (clickCount === 1) {
        clickTimer = setTimeout(() => {
          handleSingleClick();
          clickCount = 0;
        }, 250);
      } else if (clickCount === 2) {
        clearTimeout(clickTimer);
        handleDoubleClick();
        clickCount = 0;
      }
    });

    async function handleSingleClick() {
      if (isCapturing) return;
      console.log('üì∏ Single click - Capturing screenshot...');
      await captureScreenshot();
    }

    function handleDoubleClick() {
      console.log('üëÜ Double click - Opening menu...');
      if (menuContainer.classList.contains('show')) {
        closeMenu();
      } else {
        openMenu();
      }
    }

    function openMenu() {
      menuContainer.classList.add('show');
      backdrop.classList.add('show');
      tooltip.classList.remove('show');
    }

    function closeMenu() {
      menuContainer.classList.remove('show');
      backdrop.classList.remove('show');
    }

    closeButton.addEventListener('click', (e) => {
      e.stopPropagation();
      console.log('‚ùå Closing floating button...');
      if (window.electronAPI && window.electronAPI.toggleButtonVisibility) {
        window.electronAPI.toggleButtonVisibility(false);
      }
      mainButton.style.transform = 'scale(0)';
      mainButton.style.opacity = '0';
    });

    menuItems.forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = item.dataset.action;
        console.log(`‚úÖ Menu item clicked: ${action}`);
        closeMenu();
        switch (action) {
          case 'text':
            handleTextNote();
            break;
          case 'audio':
            handleAudioNote();
            break;
          case 'file':
            handleFileAttach();
            break;
        }
      });
    });

    async function captureScreenshot() {
      if (isCapturing) {
        console.log('‚ö†Ô∏è Already capturing, ignoring...');
        return;
      }
      
      isCapturing = true;

      try {
        mainButton.classList.add('capturing');
        tooltip.textContent = 'Capturing...';
        tooltip.classList.add('show');

        console.log('üì∏ Calling captureScreenshot IPC...');
        
        const result = await window.electronAPI.captureScreenshot();
        
        console.log('üì∏ Capture result:', result);
        
        if (!result.success) {
          throw new Error(result.error || 'Capture failed');
        }

        pendingCapture = result;
        
        await showCaptureNotification(result);

      } catch (error) {
        console.error('‚ùå Screenshot capture error:', error);
        mainButton.classList.remove('capturing', 'processing');
        mainIcon.textContent = '‚ùå';
        tooltip.textContent = 'Capture failed!';
        setTimeout(() => {
          mainIcon.textContent = 'üì∏';
          tooltip.classList.remove('show');
          isCapturing = false;
        }, 2000);
      }
    }

    async function showCaptureNotification(capture) {
      tooltip.textContent = 'Review & Send';
      tooltip.classList.add('show');

      try {
        console.log('üîî Calling showCaptureNotification IPC...');
        console.log('üì∏ Capture data:', {
          screenshotPath: capture.screenshotPath,
          hasContext: !!capture.context,
          capturedAt: capture.capturedAt
        });
        
        const result = await window.electronAPI.showCaptureNotification({
          screenshotPath: capture.screenshotPath,
          context: capture.context,
          capturedAt: capture.capturedAt
        });

        console.log('‚úÖ Notification window result:', result);

        if (result && result.success) {
          console.log('‚úÖ Notification window shown successfully');
          mainButton.classList.remove('capturing');
          mainButton.classList.add('processing');
        } else {
          throw new Error(result?.error || 'Failed to show notification');
        }
        
      } catch (error) {
        console.error('‚ùå Failed to show notification:', error);
        mainButton.classList.remove('capturing', 'processing');
        mainIcon.textContent = '‚ùå';
        tooltip.textContent = 'Notification failed!';
        setTimeout(() => {
          mainIcon.textContent = 'üì∏';
          tooltip.classList.remove('show');
          isCapturing = false;
        }, 2000);
      }
    }

    async function sendToBackend() {
      if (!pendingCapture) return;
      clearTimeout(autoSendTimer);
      tooltip.textContent = 'Sending...';
      const res = await window.electronAPI.sendCaptureToBackend({
        screenshotPath: pendingCapture.screenshotPath,
        context: pendingCapture.context
      });
      if (res.success) {
        tooltip.textContent = 'Saved ‚úÖ';
      } else {
        tooltip.textContent = 'Failed ‚ùå';
      }
      setTimeout(() => {
        tooltip.classList.remove('show');
        pendingCapture = null;
      }, 2000);
    }

    function handleTextNote() {
        console.log('Opening text note window...');
        window.electronAPI.openTextNoteWindow();
    }

    function handleAudioNote() {
        console.log('Opening audio note window...');
        window.electronAPI.openAudioNoteWindow();
    }
    


    function handleFileAttach() {
      console.log('üìé Opening file dialog...');
      window.electronAPI.openFileDialog().then(result => {
        if (result.success) {
          console.log('‚úÖ File selected:', result.fileName);
          tooltip.textContent = `Uploading...`;
          tooltip.classList.add('show');
          // Store the selected file for upload
          pendingFile = {
            path: result.filePath,
            name: result.fileName,
            size: result.fileSize,
            type: result.fileType
          };
          // Immediately upload after selection
          uploadPendingFile();
        } else {
          console.log('‚ÑπÔ∏è File selection:', result.message || result.error);
          tooltip.textContent = result.error || result.message || 'File selection canceled';
          tooltip.classList.add('show');
          setTimeout(() => {
            tooltip.classList.remove('show');
          }, 3000);
        }
      }).catch(error => {
        console.error('‚ùå File dialog error:', error);
        tooltip.textContent = 'File dialog error!';
        tooltip.classList.add('show');
        setTimeout(() => {
          tooltip.classList.remove('show');
        }, 2000);
      });
    }


    async function uploadPendingFile() {
      if (!pendingFile) return;
      tooltip.textContent = 'Uploading...';
      tooltip.classList.add('show');
      try {
        const res = await window.electronAPI.uploadFileToBackend(pendingFile);
        if (res.success) {
          tooltip.textContent = 'Uploaded and saved ‚úÖ';
        } else {
          tooltip.textContent = 'Failed ‚ùå: ' + (res.error || 'Unknown');
        }
      } catch (err) {
        tooltip.textContent = 'Failed ‚ùå: ' + (err.message || 'Unknown');
      }
      setTimeout(() => {
        tooltip.classList.remove('show');
        pendingFile = null;
      }, 2500);
    }

    function showTemporaryMessage(message) {
      tooltip.textContent = message;
      tooltip.classList.add('show');
      setTimeout(() => {
        tooltip.classList.remove('show');
      }, 2500);
    }

    mainButton.addEventListener('mouseenter', () => {
      if (!isCapturing && !menuContainer.classList.contains('show')) {
        tooltip.textContent = 'Click to capture ¬∑ Double-click for options';
        tooltip.classList.add('show');
      }
    });

    mainButton.addEventListener('mouseleave', () => {
      if (!isCapturing) {
        tooltip.classList.remove('show');
      }
    });

    if (window.electronAPI && window.electronAPI.onCaptureShortcut) {
      window.electronAPI.onCaptureShortcut(() => {
        console.log('‚å®Ô∏è Keyboard shortcut triggered');
        handleSingleClick();
      });
    }

    console.log('‚úÖ Floating capture button initialized');
    console.log('üí° Single click = Capture | Double click = Menu | Hover √ó = Close');
  </script>
</body>

</html>